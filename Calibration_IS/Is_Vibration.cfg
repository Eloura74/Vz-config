# ################################################
# ###### OPTIMISATIONS DES VIBRATIONS ET DE LA VITESSE ######
# ################################################
# # Rédigé par Frix_x#0161 #
# # @version: 2.0

# # JOURNAL DES MODIFICATIONS :
# #   v2.0 : ajout de la possibilité de mesurer plusieurs axes
# #   v1.0 : première macro d'optimisation de la vitesse et des vibrations

# # -------------------------------------------------------------------------------------------------------------------------
# # Si vous souhaitez l'utiliser dans votre propre configuration, veuillez l'installer en tant que macro autonome, comme décrit dans la
# # section d'installation de ce fichier : docs > features > vibr_measurements.md
# # -------------------------------------------------------------------------------------------------------------------------

# ### Qu'est-ce que c'est ? ###
# # Cette macro vous aide à identifier les paramètres de vitesse qui exacerbent les vibrations de la machine (c'est-à-dire où le châssis résonne mal).
# # Elle permet également de trouver les plages de vitesse optimales où la machine est silencieuse.
# # J'avais de fortes vibrations à des vitesses très spécifiques sur ma machine (52mm/s par exemple) et je voulais trouver toutes ces vitesses problématiques
# # pour les éviter dans mon profil de tranchage et enfin obtenir la machine silencieuse dont je rêvais !

# # Elle fonctionne en déplaçant la tête d'outil à différentes vitesses tout en enregistrant les vibrations à l'aide de la puce ADXL. Ensuite, la macro appelle un script personnalisé
# # pour calculer et trouver les meilleurs paramètres de vitesse. Les résultats se trouvent dans votre dossier de configuration à l'aide du gestionnaire de fichiers Fluidd/Mainsail.

# # L'objectif est de le rendre facile à définir, partager et utiliser.

# # Cette macro est paramétrique et la plupart des valeurs peuvent être ajustées avec leurs paramètres d'entrée respectifs.
# # Elle peut être appelée sans aucun paramètre - auquel cas les valeurs par défaut seraient utilisées - ou avec n'importe quelle combinaison de paramètres souhaitée.

# # Utilisation :
# #   1. FAITES D'ABORD VOTRE CALIBRATION DE L'AJUSTEUR D'ENTRÉE !!! Cette macro ne doit pas être utilisée avant, car elle serait inutile et les résultats invalides.
# #   2. Appelez la macro VIBRATIONS_CALIBRATION avec la plage de vitesses que vous souhaitez mesurer (par défaut de 20 à 200 mm/s avec un incrément de 2 mm/s).
# #      Faites attention à la variable Z_HEIGHT qui est par défaut à 20 mm -> si votre ADXL est sous la buse, augmentez-la pour éviter une collision de l'ADXL avec le lit de la machine.
# #   3. Attendez qu'elle termine toutes les mesures et calcule le graphique. Ensuite, examinez-le dans le dossier des résultats.


# [gcode_macro VIBRATIONS_CALIBRATION]
# gcode:
#     #
#     # PARAMÈTRES
#     #
#     {% set size = params.SIZE|default(60)|int %} # taille de la zone où les mouvements sont effectués
#     {% set direction = params.DIRECTION|default('XY') %} # peut être réglé sur XY, AB, ABXY, A, B, X, Y, Z
#     {% set z_height = params.Z_HEIGHT|default(60)|int %} # hauteur Z pour placer la tête d'outil avant de commencer les mouvements
#     {% set verbose = params.VERBOSE|default(true) %} # Indique si les vitesses actuelles doivent être enregistrées dans la console

#     {% set min_speed = params.MIN_SPEED|default(20)|int * 60 %} # débit minimum pour les mouvements
#     {% set max_speed = params.MAX_SPEED|default(200)|int * 60 %} # débit maximum pour les mouvements
#     {% set speed_increment = params.SPEED_INCREMENT|default(2)|int * 60 %} # incrément de débit entre chaque déplacement
#     {% set feedrate_travel = params.TRAVEL_SPEED|default(200)|int * 60 %} # débit de déplacement entre les déplacements

#     {% set accel_chip = params.ACCEL_CHIP|default("adxl345") %} # Nom de la puce ADXL dans la configuration

#     #
#     # VALEURS CALCULÉES
#     #
#     {% set mid_x = printer.toolhead.axis_maximum.x|float / 2 %}
#     {% set mid_y = printer.toolhead.axis_maximum.y|float / 2 %}

#     {% set direction_factor = {
#         'XY'  : {
#             'start' : {'x': -0.5, 'y': -0.5 },
#             'move_factors' : {
#                 '0' : {'x': 0.5, 'y': -0.5, 'z': 0.0 },
#                 '1' : {'x': 0.5, 'y': 0.5, 'z': 0.0 },
#                 '2' : {'x': -0.5, 'y': 0.5, 'z': 0.0 },
#                 '3' : {'x': -0.5, 'y': -0.5, 'z': 0.0 }
#                 }
#             },
#         # ... (continuation des facteurs de mouvement pour d'autres directions)
#         }
#     %}

#     #
#     # DÉBUT...
#     #
#     {% if not 'xyz' in printer.toolhead.homed_axes %}
#         { action_raise_error("Doit d'abord homologuer l'imprimante !") }
#     {% endif %}

#     {% if (size / (max_speed / 60)) < 0.25 %}
#         { action_raise_error("LA TAILLE est trop petite pour cette VITESSE MAX. Augmentez LA TAILLE ou diminuez VITESSE MAX !") }
#     {% endif %}

#     {% if not (direction in direction_factor) %}
#         { action_raise_error("LA DIRECTION n'est pas valide. Seules XY, AB, ABXY, A, B, X, Y ou Z sont autorisées !") }
#     {% endif %}

#     {action_respond_info("")}
#     {action_respond_info("Début de la calibration de la vitesse et des vibrations")}
#     {action_respond_info("Cette opération ne peut pas être interrompue normalement. Appuyez sur le bouton « arrêt d'urgence » pour l'arrêter si nécessaire")}
#     {action_respond_info("")}

#     SAVE_GCODE_STATE NAME=STATE_VIBRATIONS_CALIBRATION

#     G90

#     # Déplacement vers la position de départ
#     G1 Z{z_height}
#     G1 X{mid_x + (size * direction_factor[direction].start.x) } Y{mid_y + (size * direction_factor[direction].start.y)} F{feedrate_travel}

#     # Modèle de vibration pour chaque fréquence
#     {% for curr_speed in range(min_speed, max_speed + speed_increment) %}
#         {% if (curr_speed - min_speed) % speed_increment == 0 %}
#             {% if verbose %}
#                 RESPOND MSG="Vitesse actuelle : {(curr_speed / 60)|int} mm/s"
#             {% endif %}

#             ACCELEROMETER_MEASURE CHIP={accel_chip}
#             {% for key, factor in direction_factor[direction].move_factors|dictsort %}
#                 G1 X{mid_x + (size * factor.x) } Y{mid_y + (size * factor.y)} Z{z_height + (size * factor.z)} F{curr_speed}
#             {% endfor %}
#             ACCELEROMETER_MEASURE CHIP={accel_chip} NAME=sp{(curr_speed / 60)|int}n1

#             G4 P300
#             M400
#         {% endif %}
#     {% endfor %}

#     {% if verbose %}
#         RESPOND MSG="Génération des graphiques... Veuillez patienter une minute ou deux et regardez dans le dossier configuré."
#     {% endif %}
#     RUN_SHELL_COMMAND CMD=plot_graph PARAMS="VIBRATIONS {direction}"

#     RESTORE_GCODE_STATE NAME=STATE_VIBRATIONS_CALIBRATION
